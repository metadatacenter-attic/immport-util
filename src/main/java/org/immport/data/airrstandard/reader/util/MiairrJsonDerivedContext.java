package org.immport.data.airrstandard.reader.util;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.StringUtils;
import org.immport.data.airrstandard.util.DateUtil;
import org.immport.data.airrstandard.util.AirrStandardConstants;
import org.immport.data.airrstandard.writer.TextWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.databind.ObjectMapper;

public class MiairrJsonDerivedContext {

    /** The logger. */
    private static final Logger log = LoggerFactory.getLogger(MiairrJsonDerivedContext.class);

    //
    // Major Entities in Original JSON File
    //
    private static final String BIOSAMPLE_TAG = "biosample";
    private static final String BIOPROJECT_TAG = "bioproject";
    private static final String SRA_TAG = "sra";

    //
    // Column Names After Generating Context Map (Mostly AIRR Column Names)
    //
    private static final String INTERVENTION_COLUMN_NAME = "intervention";
    private static final String PUB_IDS_COLUMN_NAME = "pub_ids";
    private static final String AGE_COLUMN_NAME = "age";
    private static final String INCLUSION_EXCLUSION_CRITERIA_COLUMN_NAME = "inclusion_exclusion_criteria";
    private static final String LIBRARY_GENERATION_METHOD_COLUMN_NAME = "library_generation_method";
    private static final String LIBRARY_GENERATION_PROTOCOL_COLUMN_NAME = "library_generation_protocol";
    private static final String LIBRARY_GENERATION_KEY_VERSION_COLUMN_NAME = "library_generation_kit_version";
    private static final String STUDY_GROUP_DESCRIPTION_COLUMN_NAME = "study_group_description";
    private static final String SUBMITTED_BY_COLUMN_NAME = "submitted_by";

    //
    // Patterns
    //
    private static final String PUBMED_ID_PATTERN = "PMID(" + AirrStandardConstants.POSITIVE_INTEGER_PATTERN + ")";

    //
    // Derived Column Names Generated by Post Processing
    //
    private static final String AGEUNIT_DERIVED_COLUMN_NAME = "ageUnit";
    private static final String ARMORCOHORT_DERIVED_COLUMN_NAME = "armOrCohort";
    private static final String FIRSTNAME_DERIVED_COLUMN_NAME = "firstName";
    private static final String HONORIFIC_DERIVED_COLUMN_NAME = "honorific";
    private static final String INCLUSIONEXCLUSION_DERIVED_COLUMN_NAME = "inclusionExclusion";
    private static final String INTERVENTIONAGENT_DERIVED_COLUMN_NAME = "interventionAgent";
    private static final String LASTNAME_DERIVED_COLUMN_NAME = "lastName";
    private static final String PROTOCOLIDS_DERIVED_COLUMN_NAME = "protocolIds";
    private static final String PUBMEDIDS_DERIVED_COLUMN_NAME = "pubMedIds";
    private static final String TEMPLATESCHEMAVERSION_DERIVED_COLUMN_NAME = "templateSchemaVersion";
    private static final String STUDYFILE_DERIVED_COLUMN_NAME = "studyFile";
    private static final String SYSTEMDATE_DERIVED_COLUMN_NAME = "systemDate";
    private static final String TARGETENROLLMENT_DERIVED_COLUMN_NAME = "targetEnrollment";

    //
    // Inclusion/Exclusion Types Map
    //
    private static final HashMap<String, String> inclusionExclusionCriteriaTypeMap = new HashMap<String, String>();
    static {
        inclusionExclusionCriteriaTypeMap.put("include", "Inclusion");
        inclusionExclusionCriteriaTypeMap.put("exclude", "Exclusion");
    }

    public static void generateDerivedColumns(HashMap<String, Object> miairrJsonContext, String templateSchemaVersion,
            File packageDirectory, File inputFile) {
        HashMap<String, Object> bioproject = getHash(miairrJsonContext.get(BIOPROJECT_TAG));
        if (bioproject == null) {
            return;
        }
        Object biosample = miairrJsonContext.get(BIOSAMPLE_TAG);
        Object sra = miairrJsonContext.get(SRA_TAG);
        //
        // 0. Schema Template Version
        // 1. Inclusion/Exclusion Criteria
        // 2. First Name, Last Name, Honorific
        // 3. Pubmed IDs
        // 4. Determine Age Unit
        // 5. Arm Or Cohort
        // 6. Protocol IDs
        // 7. Target Enrollment
        // 8. System Date
        // 9. Intervention Agent
        // 10. Add Study Files
        // 11. Write Context File
        // 12. Write Input MiAIRR Json File
        //
        setTemplateSchemaVersion(bioproject, templateSchemaVersion);
        generateInclusionExclusion(bioproject);
        generateFileLastHonorific(bioproject);
        generatePubMedIds(bioproject);
        generateAgeUnit(bioproject, biosample);
        generateArmOrCohort(bioproject, biosample);
        generateProtocolIds(bioproject, sra, packageDirectory);
        generateTargeEnrollment(bioproject, biosample);
        generateSystemDate(bioproject);
        generateInterventionAgent(bioproject, biosample);
        //
        // Study Files
        //
        log.debug("10.  Add Study Files");
        HashMap<String, String> studyFiles = new HashMap<String, String>();
        bioproject.put(STUDYFILE_DERIVED_COLUMN_NAME, studyFiles);
        //
        // Context File
        File contextFile = addContextFileToStudyFiles(studyFiles, packageDirectory, inputFile.getName(),
                "Derived context from input json file used for transforming the input json file, " + inputFile.getName()
                        + ", into ImmPort templates");
        writeContextFile(miairrJsonContext, contextFile);
        //
        // Input MiAIRR Json File
        //
        log.debug("12.  Add Input File to studyFiles");
        studyFiles.put(inputFile.getName(), "input MiAIRR Json file");
        writeInputFile(inputFile, packageDirectory);
    }

    private static void setTemplateSchemaVersion(HashMap<String, Object> bioproject, String templateSchemaVersion) {
        log.debug("0. Schema Template Version");
        bioproject.put(TEMPLATESCHEMAVERSION_DERIVED_COLUMN_NAME, templateSchemaVersion);
    }

    private static void generateInclusionExclusion(HashMap<String, Object> bioproject) {
        log.debug("1. Inclusion/Exclusion Criteria");
        HashMap<String, String> inclusionExclusionCriteria = new HashMap<String, String>();
        bioproject.put(INCLUSIONEXCLUSION_DERIVED_COLUMN_NAME, inclusionExclusionCriteria);
        String inclusionExclusion = getValue(INCLUSION_EXCLUSION_CRITERIA_COLUMN_NAME, bioproject);
        if (inclusionExclusion == null) {
            return;
        }
        String[] criteria = inclusionExclusion.split(AirrStandardConstants.SEMI_COLON_PATTERN);
        for (String criterion : criteria) {
            criterion = StringUtils.stripToEmpty(criterion);
            String[] components = criterion.split(AirrStandardConstants.COLON_PATTERN);
            String type = inclusionExclusionCriteriaTypeMap.get(StringUtils.stripToEmpty(components[0]).toLowerCase());
            criterion = StringUtils.stripToEmpty(components[1]);
            inclusionExclusionCriteria.put(criterion, type);
        }
    }

    private static void generateFileLastHonorific(HashMap<String, Object> bioproject) {
        log.debug("2. first name, last name, honorific");
        HashMap<String, String> names = new HashMap<String, String>();
        names.put(FIRSTNAME_DERIVED_COLUMN_NAME, AirrStandardConstants.EMPTY_STR);
        names.put(LASTNAME_DERIVED_COLUMN_NAME, AirrStandardConstants.EMPTY_STR);
        names.put(HONORIFIC_DERIVED_COLUMN_NAME, AirrStandardConstants.EMPTY_STR);
        for (String name : names.keySet()) {
            bioproject.put(name, names.get(name));
        }
        String submittedBy = getValue(SUBMITTED_BY_COLUMN_NAME, bioproject);
        if (submittedBy == null) {
            return;
        }
        String[] components = submittedBy.split(AirrStandardConstants.SPACES_PATTERN);
        if (components.length >= 1) {
            names.put(LASTNAME_DERIVED_COLUMN_NAME, StringUtils.stripToEmpty(components[components.length - 1]));
        }
        if (components.length == 2) {
            names.put(FIRSTNAME_DERIVED_COLUMN_NAME, StringUtils.stripToEmpty(components[0]));
        } else if (components.length >= 3) {
            names.put(HONORIFIC_DERIVED_COLUMN_NAME, StringUtils.stripToEmpty(components[0]));
            String[] firstComponents = new String[components.length - 2];
            for (int i = 0; i < components.length - 2; i++) {
                firstComponents[i] = StringUtils.stripToEmpty(components[i + 1]);
                log.debug("comp (" + i + ") = " + firstComponents[i]);
            }
            names.put(FIRSTNAME_DERIVED_COLUMN_NAME, String.join(AirrStandardConstants.SPACE, firstComponents));
        }
        for (String name : names.keySet()) {
            bioproject.put(name, names.get(name));
        }
    }

    private static void generatePubMedIds(HashMap<String, Object> bioproject) {
        log.debug("3. pubmed IDs");
        String pubIds = getValue(PUB_IDS_COLUMN_NAME, bioproject);
        if (pubIds == null) {
            return;
        }
        String separator = AirrStandardConstants.SEMI_COLON_PATTERN;
        if (pubIds.contains(AirrStandardConstants.SEMI_COLON)) {
            separator = AirrStandardConstants.SEMI_COLON_PATTERN;
        } else if (pubIds.contains(AirrStandardConstants.COMMA_LINE)) {
            separator = AirrStandardConstants.COMMA_PATTERN;
        } else if (pubIds.contains(AirrStandardConstants.SPACE)) {
            separator = AirrStandardConstants.SPACES_PATTERN;
        }
        String[] ids = pubIds.split(separator);
        Pattern pattern = Pattern.compile(PUBMED_ID_PATTERN);
        List<String> pubMedIds = new ArrayList<String>();
        for (String id : ids) {
            id = StringUtils.stripToEmpty(id);
            if (!id.equals(AirrStandardConstants.EMPTY_STR)) {
                Matcher matcher = pattern.matcher(id);
                if (matcher.matches()) {
                    String pubmedId = matcher.group(1);
                    pubMedIds.add(pubmedId);
                }
            }
        }
        if (pubMedIds.size() > 0) {
            bioproject.put(PUBMEDIDS_DERIVED_COLUMN_NAME, pubMedIds);
        }

    }

    private static void generateAgeUnit(HashMap<String, Object> bioproject, Object biosampleObject) {
        log.debug("4. Determine Age Unit");
        String ageUnit = AirrStandardConstants.EMPTY_STR;
        bioproject.put(AGEUNIT_DERIVED_COLUMN_NAME, ageUnit);
        List<HashMap<String, Object>> biosample = getHashList(biosampleObject);
        if (biosample == null) {
            return;
        }
        for (HashMap<String, Object> bs : biosample) {
            String age = getValue(AGE_COLUMN_NAME, bs);
            if (age == null) {
                continue;
            }
            log.debug("  age = '" + age + "'");
            String[] components = age.split(AirrStandardConstants.SPACES_PATTERN);
            if (components.length >= 2) {
                log.debug("  age(2) = '" + age + "'");
                String unit = StringUtils.stripToEmpty(components[components.length - 1]);
                log.debug("  unit = '" + unit + "'");
                if (!unit.equals(AirrStandardConstants.EMPTY_STR)) {
                    log.debug("  unit(2) = '" + unit + "'");
                    if (ageUnit.equals(AirrStandardConstants.EMPTY_STR)) {
                        // set age unit once
                        ageUnit = AirrStandardConstants.upperCaseFirst(unit);
                        log.debug("  ageUnit = '" + ageUnit + "'");

                    }
                    if (!ageUnit.equalsIgnoreCase(unit)) {
                        // test age unit and break if not equal
                        ageUnit = AirrStandardConstants.EMPTY_STR;
                        log.debug("  Bad data");
                        break;
                    }
                }
            }
        }
        bioproject.put(AGEUNIT_DERIVED_COLUMN_NAME, ageUnit);
    }

    private static void generateArmOrCohort(HashMap<String, Object> bioproject, Object biosampleObject) {
        log.debug("5. Arm Or Cohort");
        List<String> armOrCohort = new ArrayList<String>();
        bioproject.put(ARMORCOHORT_DERIVED_COLUMN_NAME, armOrCohort);
        List<HashMap<String, Object>> biosample = getHashList(biosampleObject);
        if (biosample == null) {
            return;
        }
        for (HashMap<String, Object> bs : biosample) {
            String aOrC = getValue(STUDY_GROUP_DESCRIPTION_COLUMN_NAME, bs);
            if (aOrC == null || armOrCohort.contains(aOrC)) {
                continue;
            }
            armOrCohort.add(aOrC);
        }
    }

    private static void generateProtocolIds(HashMap<String, Object> bioproject, Object sraObject,
            File packageDirectory) {
        log.debug("6. Protocol IDs");
        HashMap<String, List<String[]>> files = new HashMap<String, List<String[]>>();
        HashMap<String, HashMap<String, String>> protocolIds = new HashMap<String, HashMap<String, String>>();
        bioproject.put(PROTOCOLIDS_DERIVED_COLUMN_NAME, protocolIds);
        List<HashMap<String, Object>> sra = getHashList(sraObject);
        if (sra == null) {
            return;
        }
        for (HashMap<String, Object> sraHash : sra) {
            String protIds = getValue(LIBRARY_GENERATION_KEY_VERSION_COLUMN_NAME, sraHash);
            if (protIds == null) {
                continue;
            }
            String description = getProtocolDescription(sraHash);
            String[] components = protIds.split(AirrStandardConstants.SEMI_COLON_PATTERN);
            for (String protocolId : components) {
                protocolId = StringUtils.stripToEmpty(protocolId);
                String fileName = String.join(AirrStandardConstants.DOT,
                        protocolId.replaceAll(AirrStandardConstants.SINGLE_QUOTE, "-prime")
                                .replaceAll(AirrStandardConstants.COLON, AirrStandardConstants.SPACE)
                                .replaceAll(AirrStandardConstants.SEMI_COLON, AirrStandardConstants.SPACE)
                                .replaceAll(AirrStandardConstants.COMMA, AirrStandardConstants.SPACE)
                                .replaceAll(AirrStandardConstants.DOUBLE_QUOTE_PATTERN, AirrStandardConstants.SPACE)
                                .replaceAll(AirrStandardConstants.OPEN_PAREN_PATTERN, AirrStandardConstants.SPACE)
                                .replaceAll(AirrStandardConstants.CLOSE_PAREN_PATTERN, AirrStandardConstants.SPACE)
                                .replaceAll(AirrStandardConstants.OPEN_BRACKET_PATTERN, AirrStandardConstants.SPACE)
                                .replaceAll(AirrStandardConstants.CLOSE_BRACKET_PATTERN, AirrStandardConstants.SPACE)
                                .replaceAll(AirrStandardConstants.OPEN_CURLY_BRACKET_PATTERN, AirrStandardConstants.EMPTY_STR)
                                .replaceAll(AirrStandardConstants.CLOSE_CURLY_BRACKET_PATTERN, AirrStandardConstants.SPACE)
                                .replaceAll(AirrStandardConstants.END_SPACES_PATTERN, AirrStandardConstants.EMPTY_STR)
                                .replaceAll(AirrStandardConstants.SPACES_PATTERN, AirrStandardConstants.UNDERSCORE),
                        AirrStandardConstants.TXT_SUFFIX);
                if (!protocolIds.containsKey(protocolId)) {
                    files.put(fileName, new ArrayList<String[]>());
                    HashMap<String, String> data = new HashMap<String, String>();
                    data.put("fileName", fileName);
                    data.put("description", description);
                    protocolIds.put(protocolId, data);
                }
                addSra(sraHash, protocolId, files.get(fileName));
            }
        }
        //
        // Write the Protocol Files
        //
        for (String fileName : files.keySet()) {
            TextWriter writer = null;
            File filePath = new File(packageDirectory, fileName);
            try {
                writer = new TextWriter(filePath.getCanonicalPath());
                for (String[] str : files.get(fileName)) {
                    writer.addRowContent(str);
                }
            } catch (Exception ex) {
                log.error("generateProtocolIds text file error: " + fileName);
                log.error(ex.getClass().getName() + ":" + ex.getMessage());
                ex.printStackTrace();
            } finally {
                writer.write();
            }
        }
    }

    private static String getProtocolDescription(HashMap<String, Object> sraHash) {
        String description = AirrStandardConstants.EMPTY_STR;
        String method = getValue(LIBRARY_GENERATION_METHOD_COLUMN_NAME, sraHash);
        String sraProtocol = getValue(LIBRARY_GENERATION_PROTOCOL_COLUMN_NAME, sraHash);
        if (method != null && !method.equals(AirrStandardConstants.EMPTY_STR)) {
            description = String.join(AirrStandardConstants.COLON + AirrStandardConstants.SPACE, "Protocol method",
                    method) + AirrStandardConstants.DOT;
        }
        if (sraProtocol != null && !sraProtocol.equals(AirrStandardConstants.EMPTY_STR)) {
            if (!description.equals(AirrStandardConstants.EMPTY_STR)) {
                description += AirrStandardConstants.SPACE + AirrStandardConstants.SPACE + "Protcol Description"
                        + AirrStandardConstants.COLON + AirrStandardConstants.SPACE;
            }
            description += sraProtocol;
        }
        return description;
    }

    private static File addContextFileToStudyFiles(HashMap<String, String> studyFiles, File packageDirectory,
            String miairrJsonFileName, String description) {
        log.debug("11. Add context file to studyFiles");
        String miairrrJsonFilePrefix = miairrJsonFileName.replaceFirst(AirrStandardConstants.JSON_SUFFIX_PATTERN,
                AirrStandardConstants.EMPTY_STR);
        File contextFile = new File(packageDirectory, String.join(AirrStandardConstants.DOT, miairrrJsonFilePrefix,
                AirrStandardConstants.CONTEXT_INFIX, AirrStandardConstants.JSON_SUFFIX));
        studyFiles.put(contextFile.getName(), description);
        return contextFile;
    }

    private static void writeContextFile(HashMap<String, Object> miairrJsonContext, File contextFile) {
        log.debug("11. Write Context File");
        TextWriter writer = null;
        try {
            writer = new TextWriter(contextFile.getCanonicalPath());
            String json = null;

            json = new ObjectMapper().writeValueAsString(miairrJsonContext);
            writer.addContent(json);
        } catch (Exception ex) {
            log.error(ex.getMessage(), ex);
            log.error(ex.getClass().getName() + ":" + ex.getMessage());
            ex.printStackTrace();
        } finally {
            writer.write();
        }
    }

    private static void writeInputFile(File inputFile, File packageDirectory) {
        log.debug("12. Write Input File");
        try {
            Path source = Paths.get(inputFile.getCanonicalPath());
            Path target = Paths.get(packageDirectory.getCanonicalPath(), inputFile.getName());
            Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
        } catch (Exception ex) {
            log.error("input json file copy error: " + inputFile.getName());
            log.error("Exception writeInputFile() = " + String.join(", ", ex.toString(), ex.getMessage()));
            log.error(ex.getClass().getName() + ":" + ex.getMessage());
            ex.printStackTrace();

        }
    }

    private static void generateTargeEnrollment(HashMap<String, Object> bioproject, Object biosampleObject) {
        log.debug("8. Determine Target Enrollment");
        int targetEnrollment = 0;
        bioproject.put(TARGETENROLLMENT_DERIVED_COLUMN_NAME, targetEnrollment + AirrStandardConstants.EMPTY_STR);
        List<HashMap<String, Object>> biosample = getHashList(biosampleObject);
        if (biosample == null) {
            return;
        }
        targetEnrollment = biosample.size();
        bioproject.put(TARGETENROLLMENT_DERIVED_COLUMN_NAME, targetEnrollment + AirrStandardConstants.EMPTY_STR);
    }

    private static void generateSystemDate(HashMap<String, Object> bioproject) {
        log.debug("9. Generate System Date");
        bioproject.put(SYSTEMDATE_DERIVED_COLUMN_NAME, DateUtil.getSystemDate());
    }

    private static void generateInterventionAgent(HashMap<String, Object> bioproject, Object biosampleObject) {
        log.debug("10. Intervention Agent");
        bioproject.put(INTERVENTIONAGENT_DERIVED_COLUMN_NAME, AirrStandardConstants.EMPTY_STR);
        List<HashMap<String, Object>> biosample = getHashList(biosampleObject);
        if (biosample == null) {
            return;
        }
        HashMap<String, String> interventions = new HashMap<String, String>();
        for (HashMap<String, Object> bs : biosample) {
            String intervention = getValue(INTERVENTION_COLUMN_NAME, bs);
            if (intervention == null || interventions.containsKey(intervention.toLowerCase())) {
                continue;
            }
            interventions.put(intervention.toLowerCase(), intervention);
        }
        bioproject.put(INTERVENTIONAGENT_DERIVED_COLUMN_NAME,
                String.join(AirrStandardConstants.SEMI_COLON_SPACE, interventions.values()));
    }

    private static String getValue(String key, HashMap<String, Object> object) {
        String value = null;
        if (object.containsKey(key)) {
            value = StringUtils.stripToEmpty((String) object.get(key));
            if (value.equals(AirrStandardConstants.EMPTY_STR)) {
                value = null;
            }
        }
        return value;
    }

    private static List<HashMap<String, Object>> getHashList(Object object) {
        List<HashMap<String, Object>> value = null;
        if (object != null && (object instanceof ArrayList)) {
            value = (ArrayList<HashMap<String, Object>>) object;
            if (value.size() == 0) {
                value = null;
            }
        }
        return value;
    }

    private static HashMap<String, Object> getHash(Object object) {
        HashMap<String, Object> value = null;
        if (object != null && (object instanceof HashMap)) {
            value = (HashMap<String, Object>) object;
            if (value.keySet().size() == 0) {
                value = null;
            }
        }
        return value;
    }

    private static void addSra(HashMap<String, Object> sra, String protocolId, List<String[]> str) {
        str.add(new String[] { "Start SRA for Protocol (" + protocolId + "):" });
        str.add(new String[] { "KEY", "VALUE" });
        for (String key : sra.keySet()) {
            Object value = sra.get(key);
            if (value instanceof String) {
                str.add(new String[] { key, (String) value });
            } else if (value instanceof HashMap) {
                HashMap<String, String> values = (HashMap<String, String>) value;
                StringBuffer theValue = new StringBuffer(AirrStandardConstants.EMPTY_STR);
                for (String sKey : values.keySet()) {
                    if (!theValue.toString().equals(AirrStandardConstants.EMPTY_STR)) {
                        theValue.append(AirrStandardConstants.SEMI_COLON_SPACE);
                    }
                    theValue.append(String.join(AirrStandardConstants.COLON, sKey, values.get(sKey)));
                }
                str.add(new String[] { key, theValue.toString() });
            }
        }
        str.add(new String[] { "End SRA:" });

    }

}
